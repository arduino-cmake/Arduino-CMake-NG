#=============================================================================#
# Writes the given lines of code belonging to the sketch to the given file path.
#        _sketch_lines - List of lines-of-code belonging to the sketch.
#        _file_path - Full path to the written source file.
#=============================================================================#
function(_write_source_file _sketch_lines _file_path)

    file(WRITE "${_file_path}" "") # Clear previous file's contents

    foreach (line ${_sketch_lines})
        escape_semicolon_in_string("${line}" original_line REVERSE)
        file(APPEND "${_file_path}" "${original_line}")
    endforeach ()

endfunction()

macro(_setup_regex_patterns)

    get_property(function_declaration_regex GLOBAL PROPERTY ARDUINO_CMAKE_FUNCTION_DECLARATION_REGEX_PATTERN)
    get_property(function_definition_regex GLOBAL PROPERTY ARDUINO_CMAKE_FUNCTION_DEFINITION_REGEX_PATTERN)
    get_property(preprocessor_regex GLOBAL PROPERTY ARDUINO_CMAKE_PREPROCESSOR_REGEX_PATTERN)

    string(CONCAT function_prototype_regex
            "${function_declaration_regex}"
            "|${function_definition_regex}")
    string(CONCAT code_pattern
            "${preprocessor_regex}"
            "|${function_prototype_regex}")

    set(comment_line_pattern "\\/\\/")
    set(comment_block_start_pattern "\\/\\*")
    set(comment_block_end_pattern "\\*\\/")

endmacro()

macro(_insert_platform_header _current_line _line_index)

    get_property(header_include_regex GLOBAL PROPERTY ARDUINO_CMAKE_HEADER_INCLUDE_REGEX_PATTERN)

    if ("${_current_line}" MATCHES "${header_include_regex}")
        set(include_line "${ARDUINO_CMAKE_PLATFORM_HEADER_INCLUDE_LINE}\n")
    else ()
        set(include_line "${ARDUINO_CMAKE_PLATFORM_HEADER_INCLUDE_LINE}\n\n")
        set(header_inclusion_block FALSE)
    endif ()

    list(INSERT converted_source ${_line_index} "${include_line}")

endmacro()

macro(_handle_platform_header)

    if ("${line}" MATCHES "${comment_line_pattern}")
        set(last_comment_start_index ${line_index})
        set(last_comment_end_index ${line_index})
    elseif ("${line}" MATCHES "${comment_block_start_pattern}")
        set(last_comment_start_index ${line_index})
    elseif ("${line}" MATCHES "${comment_block_end_pattern}")
        set(last_comment_end_index ${line_index})
    elseif ("${line}" MATCHES "${code_pattern}")

        set(header_inclusion_block TRUE)

        # Calculate difference between current line index and last comment's end index
        math(EXPR line_index_diff "${line_index} - ${last_comment_end_index}")

        # Comment ends above current line, any lines should be inserted above
        if (${line_index_diff} EQUAL 1)
            _insert_platform_header("${line}" ${last_comment_start_index})
        else ()
            _insert_platform_header("${line}" ${line_index})
        endif ()

        set(header_inserted TRUE)

    endif ()

endmacro()

macro(_handle_prototype_generation)

    get_property(header_include_regex GLOBAL PROPERTY ARDUINO_CMAKE_HEADER_INCLUDE_REGEX_PATTERN)

    if (NOT "${line}" MATCHES "${header_include_regex}")
        if (NOT "${line}" STREQUAL "") # Not a newline

            if (NOT header_inclusion_block)
                # Insert a newline to separate prototypes from the rest of the code
                list(INSERT converted_source ${line_index} "\n")
            endif ()

            foreach (prototype ${_sketch_prototypes})
                # Add missing semicolon to make a definition a declaration and escape it
                escape_semicolon_in_string("${prototype};" escaped_prototype)
                list(INSERT converted_source ${line_index} "${escaped_prototype}\n")
            endforeach ()

            if (header_inclusion_block)
                list(INSERT converted_source ${line_index} "\n// Prototypes generated by Arduino-CMake\n")
            else ()
                list(INSERT converted_source ${line_index} "// Prototypes generated by Arduino-CMake\n")
            endif ()

            set(prototypes_inserted TRUE)
            set(header_inclusion_block FALSE)

        endif ()
    endif ()

endmacro()

macro(_handle_simple_lines)

    if ("${line}" STREQUAL "")
        list(APPEND converted_source "\n")
    else ()
        escape_semicolon_in_string("${line}" formatted_line)
        list(APPEND converted_source "${formatted_line}\n")
    endif ()

endmacro()

#=============================================================================#
# Converts the given sketch file into a valid '.cpp' source file under the project's working dir.
# During the conversion process the platform's main header file is inserted to the source file,
# as well as any given prototypes, found earlier through a function def-dec matching process.
#       _sketch_file - Full path to the original sketch file (Read from).
#       _converted_source_path - Full path to the converted target source file (Written to).
#       _sketch_prototypes - List of prototypes to genereate, i.e. function definitions without a declaration.
#=============================================================================#
function(convert_sketch_to_source _sketch_file _converted_source_path _sketch_prototypes)

    file(STRINGS "${_sketch_file}" sketch_lines)

    _setup_regex_patterns()

    set(header_inserted FALSE)
    set(prototypes_inserted FALSE)
    set(header_inclusion_block FALSE)

    set(last_comment_start_index 0)
    set(last_comment_end_index 0)

    list_max_index("${sketch_lines}" lines_count)

    foreach (line_index RANGE ${lines_count})

        list(GET sketch_lines ${line_index} line)

        if (NOT header_inserted)
            _handle_platform_header()
        elseif (NOT prototypes_inserted)
            _handle_prototype_generation()
        endif ()

        _handle_simple_lines()

    endforeach ()

    _write_source_file("${converted_source}" "${_converted_source_path}")

endfunction()
